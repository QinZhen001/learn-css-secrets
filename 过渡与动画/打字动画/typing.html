<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>typing</title>
  <style>
    h1 {
      width: 15ch; /*文本的宽度*/
      white-space: nowrap; /*阻止文本折行*/
      overflow: hidden; /*剪裁掉超出宽度的文本*/
      border-right: 2px solid;
      animation: typing 6s steps(15),
      caret 1s steps(1) infinite;
      font: bold 200% Consolas, Monaco, monospace;
    }

    @keyframes typing {
      from {
        width: 0;
      }
    }

    @keyframes caret {
      50% {
        border-color: transparent;
      }
    }

  </style>
</head>
<body>
<h1>CSS is awesome!</h1>


<br><br><br>
核心思路就是让容器的宽度成为动画的主体： <br>
把所有文本包裹在这个容 器中，然后让它的宽度从 0 开始以步进动画的方式、一个字一个字地扩张到它应有的宽度 <br>
你可能已经察觉到了，这个方法是有局限的：它并不适用于多行文本 <br>
然而幸运的是，在绝大多数情况下，我们把这种效果应用在类似标题的单行文本上 <br>
<br><br><br>
另外一件需要注意的事情是，动画的持续时间越长，动画效果越差：持 续时间较短的动画会让界面显得更加精致，在某些场景下还是有益于可用性的 <br>
反之，动画的持续时间越长，越容易让用户感到厌烦。因此，即使这个技巧可以用在大段文本身上，也不一定是个好主意。 <br>
<br>
出现的问题： <br>
最明显的问题是整个动画是平滑连贯的，而不是逐字显现的。 <br>
另一个不那么明显的问题是，目前我们已经用 em 单位指定了宽度， 虽然它比像素单位要好一些，但仍然不够理想。我们是怎么算出来的？ <br>
<br>
我们可以用 steps() 来修复第一个问题，就像“逐帧动画”和 “闪烁效 果”中所做的那样 <br>
。但不幸的是，我们所需要的步进数量是由字符的数量来 决定的，这显然是很难维护的,可以用一小段 JavaScript 代码来把这件事情自动化 <br>
<br>
第二个问题可以通过 ch 单位来缓解 <br>
这个 ch 单位是由 CSS 值与单位,表示“0” 字形的宽度 <br>
在等宽字体中， “0”字形的宽度和其他所有字形的宽度是一样的。因此，如果我们用 ch 单位来表达这个标题的宽度，那取值实际上就是字符的数量

<br><br>
最后一步: 给它加上一个闪烁的光标
<br>
在这个例子中，我们可以用一个伪元素来生成光标，并通过 opacity 属性来实现闪烁效果； <br>
我们也可以用右边框来模拟 光标效果，这样就可以把有限的伪元素资源节省下来留作他用： <br>
<br>
这里并不需要指定边框的颜色，因为我们希望边 框颜色自动与文字颜色保持一致 <br>
<br><br><br>

浏览器是否支持 ch 单位会决定最终的显示效果 <br>
也可 以补一行以 em 作为单位的回退样式 <br>
如果你不希望在回退结果中看到一个 不能闪烁的光标，可以把生成光标的边框样式写到关键帧中，这样当浏览器 不支持动画时，就只会显示出一条看不见的透明边框了
<br>
</body>
</html>